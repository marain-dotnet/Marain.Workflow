#!meta

{"kernelInfo":{"defaultKernelName":null,"items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"html","languageName":"HTML"},{"name":"sql","languageName":"SQL"},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"httpRequest","languageName":"http"},{"name":"value"}]}}

#!markdown

# Basic Workflow Example

#!markdown

## Referencing dependencies

#!markdown

First add a reference to the `Marain.Workflow.Abstractions` NuGet package.

#!csharp

#r "nuget: Marain.Workflow.Abstractions, 0.3.0"

#!markdown

We're going to need a reference to [Corvus.Leasing](https://github.com/corvus-dotnet/Corvus.Leasing/tree/main/Solutions) since Marain.Workflow depends on it. We'll be using the in-memory version.

#!csharp

#r "nuget: Corvus.Leasing.InMemory, 1.2.9"

#!markdown

We've got some helper code in the `WorkflowExampleHelpers` folder in this directory that's going to help us set up this workflow example; we need a reference to the resulting dll.

#!csharp

// #r "bin\Debug\net6.0\Examples.dll"
#r "WorkflowExampleHelpers\bin\Debug\net7.0\WorkflowExampleHelpers.dll"

#!csharp

using Marain.Workflows;

#!markdown

## Basic workflow example

In this example we're going to be modelling the workflow of an expense claim.

#!markdown

### Create a `Workflow`

#!markdown

The first thing to do is create a workflow. We're going to have a `Workflow` with two states: `"Pending"` & `"Approved"`.

There will be single transition attached to the `"Pending"` state that has a target state of `"Approved"`; the transition will have a single condition, `SimpleApprovalCondition`, which is defined in the `SimpleApprovalCondition.cs` class file inside the `WorkflowExampleHelpers` folder in this directory. The condition has a  `bool` property which determines whether the condition passes or not. 

#!csharp

Workflow expenseClaimWorkflow = new Workflow
{
    Id = "expense claim",
    DisplayName = "Expense claim",
    InitialStateId = "Pending",
    States =
    {
        {
            "Pending",
            new WorkflowState
            {
                Id = "Pending",
                DisplayName = "Pending approval",
                Transitions =
                {
                    new WorkflowTransition
                    {
                        TargetStateId = "Approved",
                        Conditions =
                        {
                            new SimpleApprovalCondition()
                        }
                    }
                }
            }
        },

        {
            "Approved",
            new WorkflowState
            {
                Id = "Approved",
                DisplayName = "Approved"
            }
        }
    }
};

#!markdown

### Create an `IWorkflowStore` and store our workflow in it

To begin using `Marain.Worklow` for modelling workflows, we need an implementation of `IWorkflowStore`. Instead of creating an implementation of this in the notebook, we have already implemented an in memory version, which you can find in the `SimpleWorkflowStore.cs` class file inside the `WorkflowExampleHelpers` folder in this directory.

#!csharp

SimpleWorkflowStore workflowStore = new SimpleWorkflowStore();
await workflowStore.UpsertWorkflowAsync(expenseClaimWorkflow);

#!markdown

### Create workflow engine

The `WorkflowEngine` contains the logic for creating workflow instances, accepting triggers and processing them, as well as other things. The `WorkflowEngine` is, well, the engine of the workflow process - it's the thing that does the work.

To create a `WorkflowEngine` we need the following: an `IWorkflowStore`, to store `Workflow`s; an `IWorkflowInstanceStore`, to store `WorkflowInstance`s; an `ILeaseProvider`, which is a type from the [`Corvus.Leasing`](https://github.com/corvus-dotnet/corvus.leasing) library; a `string` for the `cloudEventSource` parameter, which is just an identifier for *where* the CloudEvents published by the engine are coming from; an `ICloudEventDataPublisher`, which is where the engine should publish CloudEvents to; and an `ILogger<IWorkflowEngine>`, for logging.

Again, instead of creating all of that in this notebook, we've pushed that code into class files inside the `WorkflowExampleHelpers` folder in this directory. In there we have in-memory implementations of `IWorkflowStore`, `IWorkflowInstanceStore` and `ICloudEventDataPublisher`. In the `WorkflowEngineBuilder` class in that directory, we have a  `BuildWorkflowEngine()` method that will bring all the necessary pieces together to build an in-memory `WorkflowEngine`, we just need to provide it our `SimpleWorkflowStore` containing our created workflow.

#!csharp

WorkflowEngineBuilder workflowEngineBuilder = new();
WorkflowEngine workflowEngine = workflowEngineBuilder.BuildWorkflowEngine(workflowStore);

#!markdown

### Start an instance of the workflow

The next thing to do is start an instance of the workflow. A workflow instance represents a specific item's progress through the workflow, so in this case a workflow instance is modelling a single expense claim progressing through an expense claim process.

We can start an instance of our `expenseClaimWorkflow` using the `workflowEngine.StartWorkflowInstanceAsync()` method.

#!csharp

await workflowEngine.StartWorkflowInstanceAsync(new StartWorkflowInstanceRequest
{
    WorkflowId = expenseClaimWorkflow.Id,
    WorkflowInstanceId = "MyExpenseClaim"
});

#!markdown

### Process a trigger

We're going to a raise a trigger into the engine targeting our `MyExpenseClaim` instance. The trigger will have a single subject: `"Approval"`, meaning any instances with `"Approval"` in their set of interest will process the trigger.

A subset of the set of interests for a given instance is composed of the interests of the transitions associated with the instance's current state; the set of interests for a given transition is composed of the interests from transition's conditions. The `SimpleApprovalCondition` condition on the transition attached to the `"Pending"` state of our `expenseClaimWorkflow` has an interest of `"Approval"`, therefore the `"Pending"` state has an interest of `"Approval"`, and so a trigger with a subject of `"Approval"` will be processed by our `"Pending"` state.

There's a method on the `SimpleApprovalCondition` class (in the helper code) that allows you to signal that the condition has passed (it simply changes a `bool` property on the class to `true`, which is what gets returned by the `EvaluateAsync()` method on the condition). Let's call that method so our `"MyExpenseClaim"` workflow instance will process the trigger.

#!csharp

WorkflowState expenseClaimWorkflowPendingState = expenseClaimWorkflow.GetState("Pending");
WorkflowTransition expenseClaimWorkflowPendingStateTransition = expenseClaimWorkflowPendingState.Transitions.First();
SimpleApprovalCondition condition = (SimpleApprovalCondition)expenseClaimWorkflowPendingStateTransition.Conditions.First();
condition.ApproveExpenseClaim();

#!markdown

Now raise a new `HostedWorkflowTrigger` (which is a built-in implementation of `IWorkFlowTrigger`) into the engine, with a subject of `"Approval"` and targeting our `"MyExpenseClaim"` workflow instance.

#!csharp

await workflowEngine.ProcessTriggerAsync(new HostedWorkflowTrigger
{
    Subjects = new[] {"Approval"}
},
workflowInstanceId: "MyExpenseClaim");

#!markdown

We can see that the CloudEvent that has been generated by the engine for this process has been printed to the console, which is all the `ConsoleCloudEventPublisher` does.

Now, let's check to see if the the state of our `"MyExpenseClaim"` workflow instance has changed.

#!csharp

WorkflowInstance myExpenseClaimWorkflowInstance = await workflowEngineBuilder.WorkflowInstanceStore.GetWorkflowInstanceAsync("MyExpenseClaim");
Console.WriteLine($"MyExpenseClaim workflow instance state: {myExpenseClaimWorkflowInstance.StateId}");

#!markdown

It has changed to approved, as expected. 
